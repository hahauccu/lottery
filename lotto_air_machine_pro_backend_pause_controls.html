<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>æ¨‚é€æ°£æµæ©Ÿ åŠ å¼·ç‰ˆï¼ˆä¸è¦å¾‹ç¢°æ’ + æ‰çƒå‡ºå£ï¼‰</title>
<style>
:root{color-scheme:dark}
html,body{height:100%;margin:0;background:#070a0f;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans TC",Arial}
canvas{display:block;width:100%;height:100%}
.ui{
  position:fixed;left:14px;top:14px;right:14px;z-index:10;
  display:flex;gap:10px;align-items:center;flex-wrap:wrap;
  padding:10px 12px;border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(10,14,22,.62);
  backdrop-filter:blur(10px);
  box-shadow:0 10px 40px rgba(0,0,0,.35);
}
.ui h1{margin:0 8px 0 0;font-size:13px;font-weight:800;letter-spacing:.2px;opacity:.92}
.pill{display:flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04)}
.small{font-size:12px;opacity:.78}
select,button,input[type="range"]{
  appearance:none;border-radius:12px;border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);color:#e8eef7;padding:9px 12px;font-size:12px;outline:none
}
button{cursor:pointer;font-weight:900;letter-spacing:.2px}
button:active{transform:translateY(1px)}
.result{
  position:fixed;left:50%;transform:translateX(-50%);bottom:16px;z-index:10;
  padding:10px 14px;border-radius:999px;border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.35);
  font-size:14px;font-weight:900;letter-spacing:.2px;
  box-shadow:0 10px 40px rgba(0,0,0,.35);
  max-width:min(980px,calc(100% - 28px));
  white-space:nowrap;overflow:hidden;text-overflow:ellipsis
}
kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
  font-size:11px;padding:2px 6px;border-radius:8px;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.06)}
</style>
</head>
<body>
<div class="ui">
  <h1>ğŸ± æ¨‚é€æ°£æµæ©Ÿ åŠ å¼·ç‰ˆ</h1>
  <div class="pill"><span class="small">çƒæ•¸</span><input id="count" type="range" min="24" max="90" value="60"/></div>
  <div class="pill"><span class="small">æ¹æµ</span><input id="turb" type="range" min="0" max="100" value="78"/></div>
  <div class="pill"><span class="small">æ—‹æµ</span><input id="swirl" type="range" min="0" max="100" value="72"/></div>
  <div class="pill"><span class="small">é‡åŠ›</span><input id="grav" type="range" min="0" max="100" value="52"/></div>
  <button id="start">é–‹å§‹æŠ½ç</button>
  <button id="drawone">æŠ½ä¸€é¡†</button>
  <button id="reset">é‡ç½®</button>
  <div class="small">å¿«æ·éµï¼š<kbd>Space</kbd> é–‹å§‹/æŠ½ä¸€é¡†ã€€<kbd>R</kbd> é‡ç½®</div>
</div>
<div class="result" id="res">æŒ‰ã€Œé–‹å§‹æŠ½çã€æˆ–ã€ŒæŠ½ä¸€é¡†ã€</div>
<canvas id="c"></canvas>

<script>
/** ========= Utilities ========= **/
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const rand=(a,b)=>a+Math.random()*(b-a);
const randi=(a,b)=>Math.floor(rand(a,b+1));
const choice=a=>a[(Math.random()*a.length)|0];
const TAU=Math.PI*2;
const easeOutCubic=t=>1-Math.pow(1-t,3);
const easeOutExpo=t=>(t===1?1:1-Math.pow(2,-10*t));

/** ========= Canvas / stage ========= **/
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d',{alpha:true});
let W=0,H=0,DPR=1;
function resize(){
  DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
  W=Math.max(2,window.innerWidth|0);
  H=Math.max(2,window.innerHeight|0);
  canvas.width=(W*DPR)|0; canvas.height=(H*DPR)|0;
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize',resize);resize();

/** ========= FX: particles + shake + trails ========= **/
let shake=0;
function addShake(v){ shake=Math.max(shake,v); }
function applyShake(){
  if(shake<=0) return;
  const s=shake;
  shake=Math.max(0, shake - 10);
  ctx.translate(rand(-s,s)*0.12, rand(-s,s)*0.12);
}

let parts=[];
function burst(x,y, n=90, pow=320, hueA=35, hueB=62){
  for(let i=0;i<n;i++){
    const a=rand(0,TAU);
    const sp=pow*rand(.25,1);
    parts.push({
      x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp,
      life:rand(.45,.95), t:0, r:rand(1.4,4.1),
      hue:rand(hueA,hueB), drag:rand(.90,.985)
    });
  }
}
function updateParts(dt){
  parts=parts.filter(p=>p.t<p.life);
  for(const p of parts){
    p.t+=dt;
    p.vy += 520*dt;
    p.vx *= Math.pow(p.drag, dt*60);
    p.vy *= Math.pow(p.drag, dt*60);
    p.x += p.vx*dt;
    p.y += p.vy*dt;
  }
}
function drawParts(){
  ctx.save();
  ctx.globalCompositeOperation='lighter';
  for(const p of parts){
    const k=1-(p.t/p.life);
    ctx.globalAlpha=clamp(k,0,1)*0.95;
    ctx.fillStyle=`hsl(${p.hue} 95% 60%)`;
    ctx.beginPath();
    ctx.arc(p.x,p.y,p.r*lerp(.9,2.0,k),0,TAU);
    ctx.fill();
  }
  ctx.restore();
  ctx.globalAlpha=1;
}

/** ========= Simple value noise (fast-ish) ========= **/
function hash2(i,j){
  // integer hash -> [0,1)
  let x = (i*374761393 + j*668265263) | 0;
  x = (x ^ (x >> 13)) | 0;
  x = (x * 1274126177) | 0;
  return ((x ^ (x >> 16)) >>> 0) / 4294967296;
}
function smoothstep(t){ return t*t*(3-2*t); }
function noise2(x,y){
  const xi=Math.floor(x), yi=Math.floor(y);
  const xf=x-xi, yf=y-yi;
  const u=smoothstep(xf), v=smoothstep(yf);
  const a=hash2(xi,yi), b=hash2(xi+1,yi), c=hash2(xi,yi+1), d=hash2(xi+1,yi+1);
  const x1=lerp(a,b,u), x2=lerp(c,d,u);
  return lerp(x1,x2,v); // 0..1
}
function fbm(x,y){
  // fractal noise 0..1
  let f=0, amp=0.55, freq=1;
  for(let i=0;i<3;i++){
    f += amp * noise2(x*freq, y*freq);
    amp *= 0.5; freq *= 2;
  }
  return clamp(f,0,1);
}

/** ========= UI ========= **/
const resEl=document.getElementById('res');
const countEl=document.getElementById('count');
const turbEl=document.getElementById('turb');
const swirlEl=document.getElementById('swirl');
const gravEl=document.getElementById('grav');
document.getElementById('reset').onclick=()=>reset();
document.getElementById('start').onclick=()=>startAuto();
document.getElementById('drawone').onclick=()=>drawOne();

window.addEventListener('keydown',(e)=>{
  if(e.code==='Space'){ e.preventDefault(); if(state.mode==='idle') startAuto(); else drawOne(); }
  if(e.key==='r'||e.key==='R') reset();
});

/** ========= Lotto air machine sim ========= **/
const state={
  balls:[],
  picked:[],
  mode:'idle', // idle | mixing | auto | picking | show
  t:0,
  pickCooldown:0,
  // machine geometry
  drum:{x:0,y:0,r:0},
  // exit chute
  chute:{x:0,y:0,w:0,h:0,active:false},
  tray:{x:0,y:0,w:0,h:0},
  // field
  fieldT:0,
  seed:randi(1,1e9)
};

function setResult(text){ resEl.textContent=text; }

function rr(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

function reset(){
  parts.length=0;
  state.picked.length=0;
  state.balls.length=0;
  state.mode='idle';
  state.t=0;
  state.pickCooldown=0;
  state.fieldT=0;
  state.seed=randi(1,1e9);

  // stage composition for 1080p-ish
  const baseR=Math.min(W,H)*0.34;
  state.drum={x:W*0.5, y:H*0.58, r:baseR};
  state.chute={x:W*0.5+baseR*0.62, y:H*0.22, w:baseR*0.44, h:baseR*0.30, active:false};
  state.tray={x:W*0.5-240, y:H*0.06, w:480, h:92};

  const n=+countEl.value;
  const br=clamp(Math.floor(Math.min(W,H)*0.018),10,16);
  const nums=[...Array(49)].map((_,i)=>i+1);
  for(let i=0;i<n;i++){
    const a=rand(0,TAU);
    const rr0=rand(0,state.drum.r-br-10);
    const x=state.drum.x+Math.cos(a)*rr0;
    const y=state.drum.y+Math.sin(a)*rr0;
    const num=nums[i%nums.length];
    state.balls.push({
      n:num,
      x,y,
      vx:rand(-80,80),
      vy:rand(-80,80),
      r:br,
      hue:(num*7)%360,
      // per-ball irregularities
      spin:rand(-8,8),
      jitter:rand(0.6,1.4),
      restitution:rand(0.82,0.94),
      friction:rand(0.965,0.988),
      mass:rand(0.85,1.15),
      grabbed:false,
      out:false,
      // used for non-uniform impulses
      phase:rand(0,TAU),
    });
  }

  setResult('æŒ‰ã€Œé–‹å§‹æŠ½çã€æˆ–ã€ŒæŠ½ä¸€é¡†ã€');
}

function startAuto(){
  state.picked.length=0;
  for(const b of state.balls){ b.grabbed=false; b.out=false; }
  state.mode='mixing';
  state.t=0;
  state.pickCooldown=0.25;
  state.chute.active=true;
  setResult('æ··åˆä¸­â€¦');
  burst(W*0.5,H*0.22,80,260,40,65);
  addShake(10);
}

function drawOne(){
  if(state.mode==='idle'){ startAuto(); return; }
  if(state.mode==='show') { state.mode='mixing'; state.t=0; state.pickCooldown=0.12; }
  if(state.picked.length>=6) return;
  // schedule a pick soon
  state.mode='picking';
  state.pickCooldown=Math.min(state.pickCooldown, 0.18);
}

function pickBall(){
  const candidates=state.balls.filter(b=>!b.grabbed && !b.out);
  if(!candidates.length) return;
  const b=choice(candidates);
  b.grabbed=true;
  state.picked.push(b.n);
  setResult('å·²æŠ½å‡ºï¼š' + state.picked.map(x=>String(x).padStart(2,'0')).join('  '));
  burst(b.x,b.y,90,320,38,62);
  addShake(14);
  // give it a strong impulse towards chute intake for a more "sucked out" feel
  const tx=state.chute.x - state.chute.w*0.15;
  const ty=state.chute.y + state.chute.h*0.55;
  const dx=tx-b.x, dy=ty-b.y;
  const d=Math.max(1,Math.hypot(dx,dy));
  b.vx += (dx/d)*520;
  b.vy += (dy/d)*520;
  b.spin += rand(-14,14);
}

function confine(b){
  const cx=state.drum.x, cy=state.drum.y, R=state.drum.r;
  const dx=b.x-cx, dy=b.y-cy;
  const dist=Math.hypot(dx,dy);
  const limit=R-b.r-2;
  if(dist>limit){
    const nx=dx/dist, ny=dy/dist;
    b.x=cx+nx*limit;
    b.y=cy+ny*limit;
    // reflect with per-ball restitution + a bit of tangential randomness
    const vn=b.vx*nx + b.vy*ny;
    b.vx -= (1+b.restitution)*vn*nx;
    b.vy -= (1+b.restitution)*vn*ny;
    // tangential kick makes collisions less regular
    const tx=-ny, ty=nx;
    const kick = rand(-90,90)*b.jitter;
    b.vx += tx*kick*0.02;
    b.vy += ty*kick*0.02;
  }
}

function collide(a,b){
  const dx=b.x-a.x, dy=b.y-a.y;
  const dist=Math.hypot(dx,dy);
  const min=a.r+b.r;
  if(dist===0 || dist>=min) return;

  const nx=dx/dist, ny=dy/dist;
  const overlap=min-dist;

  const ma=a.mass, mb=b.mass;
  const sum=ma+mb;
  a.x -= nx*overlap*(mb/sum);
  a.y -= ny*overlap*(mb/sum);
  b.x += nx*overlap*(ma/sum);
  b.y += ny*overlap*(ma/sum);

  const rvx=b.vx-a.vx, rvy=b.vy-a.vy;
  const vn=rvx*nx + rvy*ny;
  if(vn>0) return;

  const e=Math.min(a.restitution,b.restitution);
  const j=-(1+e)*vn / (1/ma + 1/mb);
  const ix=j*nx, iy=j*ny;
  a.vx -= ix/ma; a.vy -= iy/ma;
  b.vx += ix/mb; b.vy += iy/mb;

  // tangential friction & spin coupling (adds "messy" feel)
  const tx=-ny, ty=nx;
  const vt=rvx*tx + rvy*ty;
  const mu=0.015 + 0.02*Math.abs(vt)/400;
  const jt = clamp(-vt*mu, -140, 140);
  a.vx -= jt*tx/ma; a.vy -= jt*ty/ma;
  b.vx += jt*tx/mb; b.vy += jt*ty/mb;
  a.spin -= jt*0.004; b.spin += jt*0.004;

  if(Math.abs(vn)>180 && Math.random()<0.25){
    burst((a.x+b.x)/2,(a.y+b.y)/2, 5, 140, 40, 65);
  }
}

function update(dt){
  if(physicsPaused){ updateParts(dt); return; }

  const turb=+turbEl.value/100;
  const swirl=+swirlEl.value/100;
  const grav=+gravEl.value/100;

  state.fieldT += dt*lerp(0.9, 2.4, turb);
  state.t += dt;

  // state machine
  if(state.mode==='mixing'){
    if(state.t>lerp(1.2, 2.2, turb)){
      state.mode='auto';
      state.t=0;
      state.pickCooldown=0.18;
      setResult('æŠ½å–ä¸­â€¦ï¼ˆæœƒå¾å³å´å‡ºå£æ‰å‡ºï¼‰');
    }
  } else if(state.mode==='auto'){
    state.pickCooldown -= dt;
    if(state.pickCooldown<=0 && state.picked.length<6){
      pickBall();
      // spacing feels like machine cadence
      state.pickCooldown = lerp(0.55, 0.25, turb) + rand(-0.05,0.08);
    }
    if(state.picked.length>=6){
      state.mode='show';
      state.t=0;
    }
  } else if(state.mode==='picking'){
    state.pickCooldown -= dt;
    if(state.pickCooldown<=0 && state.picked.length<6){
      pickBall();
      state.pickCooldown = 0.35;
      state.mode = (state.picked.length>=6) ? 'show' : 'auto';
    }
  }

  const cx=state.drum.x, cy=state.drum.y, R=state.drum.r;

  // flow field parameters
  const swirlStrength = lerp(0.6, 4.8, swirl);
  const turbStrength  = lerp(50, 720, turb);
  const g = lerp(150, 980, grav);

  // a moving "fan jet" point that changes over time to break symmetry
  const jetAng = state.fieldT*1.2 + 1.6*Math.sin(state.fieldT*0.7);
  const jetX = cx + Math.cos(jetAng)*R*0.55;
  const jetY = cy + Math.sin(jetAng*0.9)*R*0.45;

  for(const b of state.balls){
    // ball already out: let it fall to the tray and settle
    if(b.out){
      b.vy += 880*dt;
      b.x += b.vx*dt; b.y += b.vy*dt;
      b.vx *= Math.pow(0.985,dt*60);
      b.vy *= Math.pow(0.985,dt*60);
      // tray bounds
      const t=state.tray;
      if(b.y > t.y + t.h - b.r){
        b.y = t.y + t.h - b.r;
        b.vy *= -0.35;
        b.vx *= 0.85;
        if(Math.abs(b.vy)<20){ b.vy=0; }
      }
      if(b.x < t.x + b.r) { b.x = t.x + b.r; b.vx *= -0.35; }
      if(b.x > t.x + t.w - b.r) { b.x = t.x + t.w - b.r; b.vx *= -0.35; }
      continue;
    }

    // grabbed: move towards chute intake, then drop out
    if(b.grabbed){
      const intakeX = state.chute.x - state.chute.w*0.08;
      const intakeY = state.chute.y + state.chute.h*0.55;
      const k = 7.0;
      b.vx += (intakeX - b.x)*k*dt;
      b.vy += (intakeY - b.y)*k*dt;
      // extra suction noise
      b.vx += rand(-1,1)*turbStrength*0.05*dt;
      b.vy += rand(-1,1)*turbStrength*0.05*dt;
      // once in chute area, release to tray
      const inChute = (
        b.x > state.chute.x - state.chute.w*0.46 &&
        b.x < state.chute.x + state.chute.w*0.10 &&
        b.y > state.chute.y + state.chute.h*0.18 &&
        b.y < state.chute.y + state.chute.h*0.90
      );
      if(inChute){
        b.out = true;
        // drop at tray center with a bit of lateral variation
        b.x = state.tray.x + state.tray.w*0.5 + rand(-80,80);
        b.y = state.tray.y - b.r - rand(12,30);
        b.vx = rand(-140,140);
        b.vy = rand(40,120);
        burst(b.x,b.y+30,80,260,35,62);
        addShake(10);
      }
    } else {
      // within drum: apply swirl + turbulence + jet impulse + per-ball jitter
      const dx=b.x-cx, dy=b.y-cy;

      // base swirl
      b.vx += (-dy)*swirlStrength*dt;
      b.vy += ( dx)*swirlStrength*dt;

      // turbulence from noise field (fbm) -> pseudo-random but smooth
      const nx = (b.x*0.004) + state.fieldT*0.22 + b.phase*0.02;
      const ny = (b.y*0.004) - state.fieldT*0.18 + b.phase*0.02;
      const n0 = fbm(nx, ny);      // 0..1
      const n1 = fbm(nx+7.13, ny+3.77);
      const ax = (n0-0.5) * turbStrength * b.jitter;
      const ay = (n1-0.5) * turbStrength * b.jitter;

      b.vx += ax*dt;
      b.vy += ay*dt;

      // fan jet (localized strong impulse)
      const jdx=b.x-jetX, jdy=b.y-jetY;
      const jd=Math.max(1,Math.hypot(jdx,jdy));
      const jet = Math.exp(- (jd*jd)/(2*(R*0.18)*(R*0.18)));
      const jtx = -jdy/jd, jty = jdx/jd;
      b.vx += jtx * jet * turbStrength * 0.22 * dt;
      b.vy += jty * jet * turbStrength * 0.22 * dt;

      // gravity
      b.vy += g*dt;

      // occasional micro-impulses to break periodicity
      if(Math.random() < 0.018*turb*dt*60){
        b.vx += rand(-220,220)*turb*b.jitter*0.25;
        b.vy += rand(-220,120)*turb*b.jitter*0.25;
        b.spin += rand(-10,10);
      }
    }

    // integrate
    b.x += b.vx*dt;
    b.y += b.vy*dt;

    // per-ball damping
    b.vx *= Math.pow(b.friction, dt*60);
    b.vy *= Math.pow(b.friction, dt*60);

    // keep inside drum
    confine(b);
  }

  // collisions inside drum only (skip out balls)
  const arr=state.balls;
  for(let i=0;i<arr.length;i++){
    const a=arr[i];
    if(a.out) continue;
    for(let j=i+1;j<arr.length;j++){
      const b=arr[j];
      if(b.out) continue;
      collide(a,b);
    }
  }

  updateParts(dt);
}

/** ========= Rendering ========= **/
function drawBackground(){
  // subtle luxury gradients
  const g1=ctx.createRadialGradient(W*0.5,H*0.26,80,W*0.5,H*0.26,Math.max(W,H));
  g1.addColorStop(0,'rgba(120,170,255,0.11)');
  g1.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=g1; ctx.fillRect(0,0,W,H);

  const g2=ctx.createRadialGradient(W*0.5,H*0.92,80,W*0.5,H*0.92,Math.max(W,H));
  g2.addColorStop(0,'rgba(255,210,120,0.10)');
  g2.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=g2; ctx.fillRect(0,0,W,H);

  // vignette
  const vg=ctx.createRadialGradient(W*0.5,H*0.55,Math.min(W,H)*0.1,W*0.5,H*0.55,Math.max(W,H));
  vg.addColorStop(0,'rgba(0,0,0,0)');
  vg.addColorStop(1,'rgba(0,0,0,0.55)');
  ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);
}

function drawMachine(){
  const {x,y,r}=state.drum;

  // outer glow
  const ring=ctx.createRadialGradient(x,y,r*0.2,x,y,r*1.25);
  ring.addColorStop(0,'rgba(255,255,255,0.08)');
  ring.addColorStop(1,'rgba(0,0,0,0.65)');
  ctx.fillStyle=ring; ctx.beginPath(); ctx.arc(x,y,r*1.08,0,TAU); ctx.fill();

  // glass boundary
  ctx.beginPath(); ctx.arc(x,y,r,0,TAU);
  ctx.strokeStyle='rgba(255,255,255,0.18)';
  ctx.lineWidth=2;
  ctx.stroke();

  // glass highlight
  ctx.beginPath();
  ctx.arc(x-r*0.18,y-r*0.20,r*0.78,-0.2,Math.PI*0.65);
  ctx.strokeStyle='rgba(200,230,255,0.10)';
  ctx.lineWidth=10;
  ctx.stroke();

  // right-side chute pipe
  const c=state.chute;
  ctx.save();
  ctx.globalAlpha=0.92;
  ctx.strokeStyle='rgba(255,255,255,0.16)';
  ctx.lineWidth=2;
  rr(c.x-c.w*0.60, c.y+c.h*0.18, c.w*0.55, c.h*0.62, 18);
  ctx.stroke();

  const pipe=ctx.createLinearGradient(c.x-c.w*0.60,0,c.x,0);
  pipe.addColorStop(0,'rgba(255,255,255,0.04)');
  pipe.addColorStop(1,'rgba(255,220,120,0.06)');
  ctx.fillStyle=pipe;
  rr(c.x-c.w*0.60, c.y+c.h*0.18, c.w*0.55, c.h*0.62, 18);
  ctx.fill();

  // intake mouth near drum
  ctx.globalAlpha=0.95;
  ctx.fillStyle='rgba(255,220,120,0.10)';
  ctx.beginPath();
  ctx.arc(c.x-c.w*0.45, c.y+c.h*0.50, 14, 0, TAU);
  ctx.fill();
  ctx.globalAlpha=1;
  ctx.restore();

  // tray for drawn balls (top area)
  const t=state.tray;
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.28)';
  ctx.strokeStyle='rgba(255,220,120,0.18)';
  ctx.lineWidth=2;
  rr(t.x,t.y,t.w,t.h,18);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle='rgba(255,255,255,0.70)';
  ctx.font='12px ui-sans-serif,system-ui';
  ctx.textAlign='center';
  ctx.fillText('æ‰çƒå‡ºå£ â†’ ä¸Šæ–¹æ”¶ç´ç›¤', t.x + t.w/2, t.y + 22);
  ctx.restore();
}

function drawBall(b){
  ctx.save();

  // shadow
  ctx.globalAlpha=0.30;
  ctx.fillStyle='black';
  ctx.beginPath();
  ctx.arc(b.x+6,b.y+9,b.r*1.02,0,TAU);
  ctx.fill();

  // glossy sphere
  ctx.globalAlpha=1;
  const g=ctx.createRadialGradient(b.x-b.r*0.35,b.y-b.r*0.35,b.r*0.25,b.x,b.y,b.r*1.15);
  g.addColorStop(0,`hsla(${b.hue} 95% 72% / 1)`);
  g.addColorStop(1,`hsla(${(b.hue+25)%360} 95% 46% / 1)`);
  ctx.fillStyle=g;
  ctx.beginPath();
  ctx.arc(b.x,b.y,b.r,0,TAU);
  ctx.fill();

  // specular
  ctx.globalAlpha=0.26;
  ctx.fillStyle='white';
  ctx.beginPath();
  ctx.arc(b.x-b.r*0.32,b.y-b.r*0.36,b.r*0.36,0,TAU);
  ctx.fill();

  // number badge
  ctx.globalAlpha=1;
  ctx.fillStyle='rgba(255,255,255,0.92)';
  ctx.beginPath();
  ctx.arc(b.x,b.y,b.r*0.58,0,TAU);
  ctx.fill();

  ctx.fillStyle='rgba(0,0,0,0.82)';
  ctx.font=`${Math.floor(b.r*0.95)}px ui-sans-serif,system-ui`;
  ctx.textAlign='center';
  ctx.textBaseline='middle';
  ctx.fillText(String(b.n).padStart(2,'0'),b.x,b.y+0.5);

  // highlight ring for grabbed
  if(b.grabbed && !b.out){
    ctx.globalAlpha=0.22;
    ctx.strokeStyle=`hsla(${b.hue} 95% 70% / 1)`;
    ctx.lineWidth=8;
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r+6,0,TAU);
    ctx.stroke();
    ctx.globalAlpha=1;
  }

  ctx.restore();
}

function draw(){
  // motion trails: draw translucent rect each frame instead of full clear
  ctx.fillStyle='rgba(7,10,15,0.22)';
  ctx.fillRect(0,0,W,H);

  drawBackground();

  ctx.save();
  applyShake();

  drawMachine();

  // clip balls inside drum for realism
  const {x,y,r}=state.drum;
  ctx.save();
  ctx.beginPath(); ctx.arc(x,y,r-1,0,TAU); ctx.clip();

  // draw non-out balls first
  for(const b of state.balls) if(!b.out) drawBall(b);
  ctx.restore();

  // draw out balls (tray)
  for(const b of state.balls) if(b.out) drawBall(b);

  drawParts();
  ctx.restore();
}

/** ========= Loop ========= **/
let last=performance.now();
function loop(now){
  const dt=Math.min(0.033,(now-last)/1000);
  last=now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
reset();
// warm clear
ctx.fillStyle='#070a0f'; ctx.fillRect(0,0,W,H);
requestAnimationFrame(loop);

/* ================= Backend controlled winners API ================= */

let backendWinners = [];
let carouselOffset = 0;

// Overlay UI for winners
const winnerBar = document.createElement('div');
winnerBar.style.cssText = `
position:fixed;left:50%;transform:translateX(-50%);
top:18px;display:flex;gap:10px;z-index:20;
`;
document.body.appendChild(winnerBar);

function renderCarousel(){
  winnerBar.innerHTML = '';
  if(!state.picked.length) return;

  const show = state.picked.slice(carouselOffset, carouselOffset+5);
  show.forEach(n=>{
    const d=document.createElement('div');
    d.textContent=String(n).padStart(2,'0');
    d.style.cssText=`
      width:48px;height:48px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      font-weight:900;font-size:16px;color:#000;
      background:radial-gradient(circle at 30% 30%, #fff, #ffcc66 55%, #cc8a00);
      box-shadow:0 0 16px rgba(255,210,120,.6);
    `;
    winnerBar.appendChild(d);
  });

  if(state.picked.length>5){
    setTimeout(()=>{
      carouselOffset = (carouselOffset+5) % state.picked.length;
      renderCarousel();
    },2000);
  }
}

// Backend API
window.setWinners = function(arr){
  backendWinners = arr.slice();
  state.picked.length = 0;
  carouselOffset = 0;
  setResult('å·²è¨­å®šä¸­ççƒï¼š' + backendWinners.join(', '));
  renderCarousel();
}

window.startDraw = function(){
  if(!backendWinners.length){
    alert('å°šæœªè¨­å®šä¸­ççƒ');
    return;
  }
  startAuto();
}

// Override pickBall to use backend list
const __oldPickBall = pickBall;
pickBall = function(){
  if(!backendWinners.length) return;

  const num = backendWinners.shift();
  const b = state.balls.find(x=>x.n===num && !x.out && !x.grabbed);
  if(!b) return;

  b.grabbed = true;
  state.picked.push(b.n);
  setResult('å·²æŠ½å‡ºï¼š' + state.picked.map(x=>String(x).padStart(2,'0')).join('  '));
  renderCarousel();

  burst(b.x,b.y,90,320,38,62);
  addShake(14);

  const tx=state.chute.x - state.chute.w*0.15;
  const ty=state.chute.y + state.chute.h*0.55;
  const dx=tx-b.x, dy=ty-b.y;
  const d=Math.max(1,Math.hypot(dx,dy));
  b.vx += (dx/d)*520;
  b.vy += (dy/d)*520;
}

// demo helper
window.demoBackend = function(){
  const nums=[];
  while(nums.length<8){
    const n=Math.floor(Math.random()*49)+1;
    if(!nums.includes(n)) nums.push(n);
  }
  setWinners(nums);
  startDraw();
}


/* ================= Pause on finish ================= */
let physicsPaused = false;

const __origStartAuto = startAuto;
startAuto = function(){
  physicsPaused = false;
  __origStartAuto();
};

const __origPickBall2 = pickBall;
pickBall = function(){
  __origPickBall2();
  if(typeof backendWinners !== 'undefined' && backendWinners.length===0){
    setTimeout(()=>{
      physicsPaused = true;
      try{
        setResult((document.getElementById('res')?.textContent||'') + '  ï¼ˆå‹•ç•«å·²æš«åœï¼‰');
      }catch(e){}
    },1200);
  }
};


/* ================= Manual pause / resume API =================

Public APIs for backend or console:

pauseMachine()    -> immediately pause all ball physics
resumeMachine()   -> resume physics simulation
slowStopMachine() -> smoothly slow down all motion and then pause

============================================================== */

// Immediately pause physics
window.pauseMachine = function(){
  physicsPaused = true;
  try{
    setResult((document.getElementById('res')?.textContent||'') + '  ï¼ˆæ‰‹å‹•æš«åœï¼‰');
  }catch(e){}
};

// Resume physics
window.resumeMachine = function(){
  physicsPaused = false;
  try{
    setResult((document.getElementById('res')?.textContent||'').replace('ï¼ˆæ‰‹å‹•æš«åœï¼‰','').replace('ï¼ˆå‹•ç•«å·²æš«åœï¼‰',''));
  }catch(e){}
};

// Smooth slow-down then pause (cinematic effect)
window.slowStopMachine = function(){
  let factor = 1.0;

  const slowTimer = setInterval(()=>{
    factor *= 0.85; // exponential slow down

    // scale velocities of all balls
    for(const b of state.balls){
      b.vx *= factor;
      b.vy *= factor;
      b.spin *= factor;
    }

    if(factor < 0.05){
      clearInterval(slowTimer);
      physicsPaused = true;
      try{
        setResult((document.getElementById('res')?.textContent||'') + '  ï¼ˆå¹³æ»‘åœæ©Ÿï¼‰');
      }catch(e){}
    }
  }, 60);
};


</script>
</body>
</html>
