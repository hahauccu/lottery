<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>å‰ç«¯æŠ½ç Demoï¼šæ‹‰éœ¸ + æ¨‚é€å½©çƒç¢°æ’ï¼ˆå–®æª” HTMLï¼‰</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#0b0f14; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial; }
    .wrap { height: 100%; display: grid; grid-template-rows: auto 1fr auto; gap: 10px; padding: 12px; box-sizing: border-box; }
    .topbar, .bottombar {
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px; padding: 10px 12px;
      backdrop-filter: blur(8px);
    }
    .topbar h1 { font-size: 14px; margin:0; font-weight: 650; letter-spacing:.2px; opacity:.9; }
    .chip { display:flex; align-items:center; gap:8px; padding: 6px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.03); }
    label { font-size: 12px; opacity:.85; }
    select, button, input[type="range"] {
      appearance: none; border-radius: 10px; border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06); color: #e8eef7; padding: 8px 10px; font-size: 12px;
      outline: none;
    }
    button { cursor:pointer; font-weight:650; }
    button:active { transform: translateY(1px); }
    input[type="range"] { padding: 0; height: 34px; width: 180px; }
    .hint { font-size: 12px; opacity:.75; margin-left:auto; white-space: nowrap; }
    .stage {
      position: relative;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: radial-gradient(900px 500px at 50% 25%, rgba(120,170,255,.10), transparent 60%),
                  radial-gradient(700px 400px at 50% 85%, rgba(255,210,120,.08), transparent 60%),
                  rgba(255,255,255,.02);
      overflow: hidden;
      min-height: 420px;
    }
    canvas { width:100%; height:100%; display:block; }
    .overlay {
      position:absolute; inset: 0; pointer-events:none;
      display:flex; align-items:flex-start; justify-content:center;
      padding: 12px;
    }
    .badge {
      pointer-events:none;
      display:flex; gap:10px; align-items:center;
      padding: 8px 12px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      font-size: 12px; opacity:.92;
    }
    .kbd {
      border: 1px solid rgba(255,255,255,.18);
      padding: 2px 6px; border-radius: 6px;
      background: rgba(255,255,255,.06);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
    }
    .bottombar { justify-content: space-between; }
    .result {
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      font-size: 12px; opacity:.9;
    }
    .pill {
      display:inline-flex; align-items:center; justify-content:center;
      min-width: 34px; height: 28px; padding: 0 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight: 750;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <h1>æŠ½ç Demoï¼ˆå–®æª”ï¼‰ï¼šæ‹‰éœ¸ + æ¨‚é€å½©çƒç¢°æ’</h1>

    <div class="chip">
      <label>æ¨¡å¼</label>
      <select id="mode">
        <option value="lotto">æ¨‚é€å½©çƒï¼ˆç¢°æ’/æ··åˆ/æŠ½å–ï¼‰</option>
        <option value="slot">æ‹‰éœ¸ï¼ˆè½‰è»¸/æ¸›é€Ÿ/åœè¼ªï¼‰</option>
      </select>
    </div>

    <div class="chip">
      <label>å¼·åº¦</label>
      <input id="power" type="range" min="0" max="100" value="65" />
    </div>

    <button id="action">é–‹å§‹</button>
    <button id="reset">é‡ç½®</button>

    <div class="hint">å¿«æ·éµï¼š<span class="kbd">Space</span> é–‹å§‹ / <span class="kbd">R</span> é‡ç½® / <span class="kbd">1</span> æ¨‚é€ / <span class="kbd">2</span> æ‹‰éœ¸</div>
  </div>

  <div class="stage">
    <canvas id="c"></canvas>
    <div class="overlay">
      <div class="badge" id="badge"></div>
    </div>
  </div>

  <div class="bottombar">
    <div class="result" id="result"></div>
    <div class="result" style="opacity:.75">
      æç¤ºï¼šé€™å€‹ demo ä¸ç”¨ GIF/å½±ç‰‡/Lottieï¼›å…¨éƒ¨ç”¨ Canvas + JS å³æ™‚ç¹ªè£½èˆ‡é‹å‹•ã€‚
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a, b) => a + Math.random() * (b - a);
  const choice = (arr) => arr[(Math.random() * arr.length) | 0];
  const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
  const easeOutExpo = (t) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));

  // ---------- Canvas Setup ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });
  const badge = document.getElementById("badge");
  const resultEl = document.getElementById("result");

  let W = 0, H = 0, DPR = 1;
  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    W = Math.max(2, Math.floor(rect.width));
    H = Math.max(2, Math.floor(rect.height));
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  // ---------- UI ----------
  const modeSel = document.getElementById("mode");
  const powerRange = document.getElementById("power");
  const actionBtn = document.getElementById("action");
  const resetBtn = document.getElementById("reset");

  function setBadge(text) { badge.textContent = text; }
  function setResult(html) { resultEl.innerHTML = html; }

  // ---------- Shared FX (particles) ----------
  let sparks = [];
  function burst(x, y, n, mag) {
    for (let i = 0; i < n; i++) {
      const a = rand(0, Math.PI * 2);
      const sp = rand(0.5, 1.2) * mag;
      sparks.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        life: rand(0.35, 0.75),
        t: 0,
        r: rand(1.2, 3.5),
        hue: rand(35, 55)
      });
    }
  }
  function updateSparks(dt) {
    sparks = sparks.filter(p => p.t < p.life);
    for (const p of sparks) {
      p.t += dt;
      p.vx *= Math.pow(0.25, dt);
      p.vy *= Math.pow(0.25, dt);
      p.vy += 220 * dt; // slight gravity
      p.x += p.vx * dt;
      p.y += p.vy * dt;
    }
  }
  function drawSparks() {
    for (const p of sparks) {
      const k = 1 - (p.t / p.life);
      ctx.globalAlpha = clamp(k, 0, 1);
      ctx.beginPath();
      ctx.fillStyle = `hsl(${p.hue} 95% 60%)`;
      ctx.arc(p.x, p.y, p.r * lerp(0.8, 1.6, k), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // ============================================================
  //  MODE A: LOTTO BALLS (collision + mixing + pick)
  // ============================================================
  const lotto = {
    balls: [],
    picked: [],
    state: "idle", // idle | mixing | picking | show
    mixT: 0,
    pickCooldown: 0,
    drum: { x: 0, y: 0, r: 0, pocketW: 0, pocketH: 0 },
  };

  function lottoReset() {
    lotto.balls.length = 0;
    lotto.picked.length = 0;
    lotto.state = "idle";
    lotto.mixT = 0;
    lotto.pickCooldown = 0;

    const r = Math.min(W, H) * 0.33;
    lotto.drum.x = W * 0.5;
    lotto.drum.y = H * 0.52;
    lotto.drum.r = r;
    lotto.drum.pocketW = Math.min(320, W * 0.72);
    lotto.drum.pocketH = 78;

    const count = clamp(Math.floor(lerp(24, 70, (+powerRange.value)/100)), 18, 90);
    const ballR = clamp(Math.floor(Math.min(W, H) * 0.018), 10, 16);

    // numbers like lotto balls: 01..49 (loop)
    const nums = [];
    for (let i = 1; i <= 49; i++) nums.push(i);

    for (let i = 0; i < count; i++) {
      const n = nums[i % nums.length];
      const a = rand(0, Math.PI * 2);
      const rr = rand(0, r - ballR - 8);
      const x = lotto.drum.x + Math.cos(a) * rr;
      const y = lotto.drum.y + Math.sin(a) * rr;
      lotto.balls.push({
        n,
        x, y,
        vx: rand(-60, 60),
        vy: rand(-60, 60),
        r: ballR,
        hue: (n * 7) % 360,
        grabbed: false
      });
    }

    setResult(`<span>å·²æŠ½å‡ºï¼š</span>`);
    setBadge("æ¨‚é€æ¨¡å¼ï¼šæŒ‰ã€Œé–‹å§‹ã€â†’æ··åˆâ†’é€é¡†æŠ½å‡ºï¼ˆå«ç¢°æ’ï¼‰");
  }

  function lottoStart() {
    if (lotto.state === "idle" || lotto.state === "show") {
      lotto.picked.length = 0;
      lotto.state = "mixing";
      lotto.mixT = 0;
      lotto.pickCooldown = 0;
      setResult(`<span>å·²æŠ½å‡ºï¼š</span>`);
      burst(W*0.5, H*0.2, 40, 120);
    }
  }

  // Circle vs circle elastic collision (equal mass)
  function resolveBallCollision(a, b) {
    const dx = b.x - a.x, dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const minDist = a.r + b.r;
    if (dist === 0 || dist >= minDist) return;

    const nx = dx / dist, ny = dy / dist;
    const overlap = (minDist - dist);

    // separate
    a.x -= nx * overlap * 0.5;
    a.y -= ny * overlap * 0.5;
    b.x += nx * overlap * 0.5;
    b.y += ny * overlap * 0.5;

    // relative velocity along normal
    const rvx = b.vx - a.vx;
    const rvy = b.vy - a.vy;
    const vn = rvx * nx + rvy * ny;

    if (vn > 0) return; // moving apart

    const restitution = 0.92; // bounciness
    const j = -(1 + restitution) * vn / 2; // equal mass
    const ix = j * nx, iy = j * ny;

    a.vx -= ix;
    a.vy -= iy;
    b.vx += ix;
    b.vy += iy;

    // sparkle
    if (Math.abs(vn) > 140) burst((a.x+b.x)*0.5, (a.y+b.y)*0.5, 2, 80);
  }

  function confineToDrum(ball) {
    const { x: cx, y: cy, r: R } = lotto.drum;
    const dx = ball.x - cx, dy = ball.y - cy;
    const dist = Math.hypot(dx, dy);
    const limit = R - ball.r - 2;
    if (dist > limit) {
      const nx = dx / dist, ny = dy / dist;
      ball.x = cx + nx * limit;
      ball.y = cy + ny * limit;

      // reflect velocity
      const vn = ball.vx * nx + ball.vy * ny;
      ball.vx -= 2 * vn * nx;
      ball.vy -= 2 * vn * ny;

      // energy loss
      ball.vx *= 0.95;
      ball.vy *= 0.95;
    }
  }

  function lottoUpdate(dt) {
    const p = (+powerRange.value) / 100;

    // mixing force and turbulence
    const spin = lerp(1.2, 3.6, p);
    const turbulence = lerp(120, 420, p);

    // state transitions
    if (lotto.state === "mixing") {
      lotto.mixT += dt;
      if (lotto.mixT > lerp(1.6, 3.0, p)) {
        lotto.state = "picking";
        lotto.pickCooldown = 0.25;
      }
    }

    // pick logic
    if (lotto.state === "picking") {
      lotto.pickCooldown -= dt;
      if (lotto.pickCooldown <= 0 && lotto.picked.length < 6) {
        // choose a ball not yet picked
        const candidates = lotto.balls.filter(b => !b.grabbed);
        if (candidates.length) {
          const b = choice(candidates);
          b.grabbed = true;
          lotto.picked.push(b);

          // show result pill
          const pills = lotto.picked.map(x => {
            const s = String(x.n).padStart(2, "0");
            return `<span class="pill">${s}</span>`;
          }).join("");
          setResult(`<span>å·²æŠ½å‡ºï¼š</span>${pills}`);

          // kickoff burst + send ball to pocket
          burst(b.x, b.y, 26, 220);
          lotto.pickCooldown = lerp(0.35, 0.20, p);
        }
      }
      if (lotto.picked.length >= 6) lotto.state = "show";
    }

    // update physics
    const g = 520; // gravity inside drum
    const drag = 0.985;

    // swirling field around center
    for (const b of lotto.balls) {
      // if grabbed, guide to pocket (top)
      if (b.grabbed) {
        const targetX = W * 0.5 + (lotto.picked.indexOf(b) - 2.5) * 52;
        const targetY = 64;
        const k = 8.5;
        b.vx += (targetX - b.x) * k * dt;
        b.vy += (targetY - b.y) * k * dt;
        b.vx *= Math.pow(0.35, dt);
        b.vy *= Math.pow(0.35, dt);
      } else {
        const dx = b.x - lotto.drum.x;
        const dy = b.y - lotto.drum.y;
        // tangential (swirl)
        b.vx += (-dy) * spin * dt;
        b.vy += ( dx) * spin * dt;
        // turbulence
        b.vx += rand(-1, 1) * turbulence * dt;
        b.vy += rand(-1, 1) * turbulence * dt;
        // gravity-ish
        b.vy += g * dt;
      }

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      b.vx *= Math.pow(drag, dt * 60);
      b.vy *= Math.pow(drag, dt * 60);

      confineToDrum(b);
    }

    // collisions (O(n^2) for demo; keep count reasonable)
    const balls = lotto.balls;
    for (let i = 0; i < balls.length; i++) {
      for (let j = i + 1; j < balls.length; j++) {
        resolveBallCollision(balls[i], balls[j]);
      }
    }
  }

  function drawDrum() {
    const { x, y, r } = lotto.drum;

    // soft vignette
    ctx.save();
    const grd = ctx.createRadialGradient(x, y, r*0.2, x, y, r*1.25);
    grd.addColorStop(0, "rgba(255,255,255,0.10)");
    grd.addColorStop(1, "rgba(0,0,0,0.55)");
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(x, y, r*1.08, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // glass drum outline
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // inner shine
    ctx.beginPath();
    ctx.arc(x- r*0.18, y- r*0.22, r*0.78, -0.2, Math.PI*0.65);
    ctx.strokeStyle = "rgba(200,230,255,0.10)";
    ctx.lineWidth = 10;
    ctx.stroke();
    ctx.restore();

    // pocket / tray for picked balls
    const pw = lotto.drum.pocketW;
    const ph = lotto.drum.pocketH;
    const px = W*0.5 - pw/2;
    const py = 24;

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.30)";
    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = 1.5;
    roundRect(px, py, pw, ph, 14);
    ctx.fill();
    ctx.stroke();

    // label
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "12px ui-sans-serif, system-ui";
    ctx.textAlign = "left";
    ctx.fillText("æŠ½å‡ºçƒæ§½", px + 12, py + 18);
    ctx.restore();
  }

  function roundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function drawBall(b) {
    // ball body
    const shadow = 8;
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.arc(b.x + shadow*0.35, b.y + shadow*0.5, b.r * 1.02, 0, Math.PI*2);
    ctx.fill();

    const g = ctx.createRadialGradient(b.x - b.r*0.35, b.y - b.r*0.35, b.r*0.25, b.x, b.y, b.r*1.15);
    g.addColorStop(0, `hsla(${b.hue} 95% 70% / 1)`);
    g.addColorStop(1, `hsla(${(b.hue+25)%360} 95% 45% / 1)`);
    ctx.beginPath();
    ctx.fillStyle = g;
    ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
    ctx.fill();

    // specular highlight
    ctx.globalAlpha = 0.35;
    ctx.beginPath();
    ctx.fillStyle = "white";
    ctx.arc(b.x - b.r*0.32, b.y - b.r*0.36, b.r*0.35, 0, Math.PI*2);
    ctx.fill();

    // number plate
    ctx.globalAlpha = 1;
    ctx.beginPath();
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.arc(b.x, b.y, b.r*0.58, 0, Math.PI*2);
    ctx.fill();

    // number text
    const s = String(b.n).padStart(2, "0");
    ctx.fillStyle = "rgba(0,0,0,0.82)";
    ctx.font = `${Math.floor(b.r*0.95)}px ui-sans-serif, system-ui`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(s, b.x, b.y + 0.5);

    // grabbed glow
    if (b.grabbed) {
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.strokeStyle = `hsla(${b.hue} 95% 70% / 1)`;
      ctx.lineWidth = 8;
      ctx.arc(b.x, b.y, b.r + 6, 0, Math.PI*2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function lottoDraw() {
    drawDrum();

    // clip balls to drum area for cleaner look
    const { x, y, r } = lotto.drum;
    ctx.save();
    ctx.beginPath();
    ctx.arc(x, y, r - 1, 0, Math.PI * 2);
    ctx.clip();

    // draw balls (non-grabbed first, grabbed last)
    for (const b of lotto.balls.filter(x => !x.grabbed)) drawBall(b);
    for (const b of lotto.balls.filter(x => x.grabbed)) drawBall(b);

    ctx.restore();
  }

  // ============================================================
  //  MODE B: SLOT MACHINE (3 reels, easing stop)
  // ============================================================
  const slot = {
    reels: [],
    symbols: ["7", "â˜…", "â—†", "â¤", "ğŸ’", "ğŸ””", "BAR", "ğŸ‹"],
    state: "idle", // idle | spinning | stopping | show
    t: 0,
    win: null
  };

  function slotReset() {
    slot.reels = [0,1,2].map(i => makeReel(i));
    slot.state = "idle";
    slot.t = 0;
    slot.win = null;
    setResult(`<span>çµæœï¼š</span>`);
    setBadge("æ‹‰éœ¸æ¨¡å¼ï¼šæŒ‰ã€Œé–‹å§‹ã€â†’è½‰å‹•â†’ä¾åºåœè¼ªï¼ˆå«æ¸›é€Ÿï¼‰");
  }

  function makeReel(index) {
    const items = [];
    for (let i = 0; i < 30; i++) items.push(choice(slot.symbols));
    return {
      items,
      pos: rand(0, items.length),  // float index
      v: 0,
      stopAt: null,
      stopT: 0,
      stopping: false,
      idx: index
    };
  }

  function slotStart() {
    if (slot.state === "spinning" || slot.state === "stopping") return;
    slot.state = "spinning";
    slot.t = 0;
    slot.win = null;

    const p = (+powerRange.value) / 100;
    const base = lerp(18, 34, p);

    for (let i = 0; i < slot.reels.length; i++) {
      const r = slot.reels[i];
      r.v = base + i * 3;
      r.stopping = false;
      r.stopAt = null;
      r.stopT = 0;
    }

    // schedule stops
    const picks = [choice(slot.symbols), choice(slot.symbols), choice(slot.symbols)];
    // (you can force a win occasionally by syncing picks)
    if (Math.random() < 0.18) picks[1] = picks[2] = picks[0];

    for (let i = 0; i < 3; i++) {
      const r = slot.reels[i];
      // choose a stop index in items that equals picks[i]
      const indices = [];
      for (let k = 0; k < r.items.length; k++) if (r.items[k] === picks[i]) indices.push(k);
      let target = choice(indices);

      // stop line is center row. We want r.pos to land so center row shows target.
      // If we render 3 rows with center at integer index, then r.pos should end at target.
      r.stopAt = target;
    }

    slot.win = picks;
    burst(W*0.5, H*0.22, 44, 160);
  }

  function slotUpdate(dt) {
    const p = (+powerRange.value) / 100;
    slot.t += dt;

    // after a bit, start stopping reels one by one
    if (slot.state === "spinning" && slot.t > lerp(0.65, 0.35, p)) {
      slot.state = "stopping";
      slot.reels[0].stopping = true;
    }

    const stopGap = lerp(0.38, 0.22, p);

    for (let i = 0; i < slot.reels.length; i++) {
      const r = slot.reels[i];

      if (slot.state === "spinning") {
        r.pos = (r.pos + r.v * dt) % r.items.length;
      } else if (slot.state === "stopping") {
        // start stopping next reel after previous has settled a bit
        if (i > 0 && slot.reels[i-1].stopping && slot.reels[i-1].stopT > stopGap && !r.stopping) {
          r.stopping = true;
          burst(W*0.5 + (i-1-1)*110, H*0.5, 10, 120);
        }

        if (!r.stopping) {
          r.pos = (r.pos + r.v * dt) % r.items.length;
          continue;
        }

        // stopping easing: slow down and land exactly on stopAt
        r.stopT += dt;
        const dur = lerp(0.75, 0.48, p);
        const t = clamp(r.stopT / dur, 0, 1);
        const e = easeOutExpo(t);

        // compute a forward distance to land on stopAt after some full spins
        const cur = r.pos;
        const target = r.stopAt;

        // forward delta in [0, len)
        let delta = target - cur;
        while (delta < 0) delta += r.items.length;

        // add extra spins to feel luxurious
        const extraTurns = 2 + i; // 2,3,4
        const total = delta + extraTurns * r.items.length;

        // interpolate along total distance
        const pos = cur + total * (e) - (total * (t>0?0:0));
        r.pos = pos % r.items.length;

        // add small "thunk" near end
        if (t > 0.92 && t < 0.94) burst(W*0.5 + (i-1)*110, H*0.5, 6, 90);

        if (t >= 1) {
          r.pos = target;
          r.v = 0;
          // if last reel stopped -> show
          if (i === 2) {
            slot.state = "show";
            const isWin = slot.win && slot.win[0] === slot.win[1] && slot.win[1] === slot.win[2];
            if (isWin) burst(W*0.5, H*0.5, 140, 260);
            const pills = slot.win.map(s => `<span class="pill">${escapeHtml(s)}</span>`).join("");
            setResult(`<span>çµæœï¼š</span>${pills} ${isWin ? `<span class="pill">WIN</span>` : ""}`);
          }
        }
      }
    }
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (m) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
  }

  function slotDraw() {
    const cx = W * 0.5;
    const cy = H * 0.55;

    const frameW = Math.min(520, W * 0.92);
    const frameH = Math.min(300, H * 0.68);
    const x = cx - frameW/2;
    const y = cy - frameH/2;

    // frame
    ctx.save();
    roundRect(x, y, frameW, frameH, 18);
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // top glow
    const g = ctx.createLinearGradient(0, y, 0, y + frameH);
    g.addColorStop(0, "rgba(255,255,255,0.08)");
    g.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = g;
    roundRect(x+2, y+2, frameW-4, frameH-4, 16);
    ctx.fill();
    ctx.restore();

    // reels window
    const pad = 20;
    const winX = x + pad;
    const winY = y + pad;
    const winW = frameW - pad*2;
    const winH = frameH - pad*2;

    ctx.save();
    roundRect(winX, winY, winW, winH, 14);
    ctx.clip();

    // reels
    const reelW = winW / 3;
    const rowH = winH / 3;

    // separator lines
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    for (let i=1;i<3;i++){
      ctx.beginPath();
      ctx.moveTo(winX + i*reelW, winY);
      ctx.lineTo(winX + i*reelW, winY + winH);
      ctx.stroke();
    }
    for (let r=1;r<3;r++){
      ctx.beginPath();
      ctx.moveTo(winX, winY + r*rowH);
      ctx.lineTo(winX + winW, winY + r*rowH);
      ctx.stroke();
    }

    // draw symbols
    for (let i=0;i<3;i++){
      const reel = slot.reels[i];
      const baseX = winX + i*reelW;
      const centerIndex = reel.pos; // float
      const center = Math.floor(centerIndex);
      const frac = centerIndex - center;

      for (let row=-1; row<=1; row++){
        const idx = (center + row + reel.items.length) % reel.items.length;
        const sym = reel.items[idx];

        const cellX = baseX;
        const cellY = winY + (row+1)*rowH;

        // animate vertical offset based on frac (scroll)
        const offset = -frac * rowH;

        // cell bg
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.fillStyle = "rgba(255,255,255,0.06)";
        ctx.fillRect(cellX, cellY + offset, reelW, rowH);

        // symbol
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const isCenter = (row === 0);
        ctx.font = `${isCenter ? 54 : 44}px ui-sans-serif, system-ui`;
        ctx.fillText(sym, cellX + reelW/2, cellY + rowH/2 + offset);

        // slight glow for center line
        if (isCenter) {
          ctx.globalAlpha = 0.18;
          ctx.strokeStyle = "rgba(255,220,120,0.95)";
          ctx.lineWidth = 6;
          ctx.strokeRect(cellX+10, cellY+10+offset, reelW-20, rowH-20);
        }
        ctx.restore();
      }
    }

    ctx.restore();

    // center line highlight
    ctx.save();
    ctx.strokeStyle = "rgba(255,220,120,0.22)";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.moveTo(winX, winY + winH/2);
    ctx.lineTo(winX + winW, winY + winH/2);
    ctx.stroke();
    ctx.restore();

    // lever (simple)
    ctx.save();
    const leverX = x + frameW + 18;
    const leverY = y + frameH*0.25;
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 10;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(x + frameW + 4, y + frameH*0.22);
    ctx.lineTo(x + frameW + 4, y + frameH*0.68);
    ctx.stroke();
    ctx.fillStyle = "rgba(255,255,255,0.16)";
    ctx.beginPath();
    ctx.arc(x + frameW + 4, y + frameH*0.18, 14, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "rgba(255,220,120,0.9)";
    ctx.beginPath();
    ctx.arc(x + frameW + 4, y + frameH*0.70, 16, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // ============================================================
  //  Main Loop
  // ============================================================
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    ctx.clearRect(0, 0, W, H);

    if (modeSel.value === "lotto") {
      lottoUpdate(dt);
      lottoDraw();
    } else {
      slotUpdate(dt);
      slotDraw();
    }

    updateSparks(dt);
    drawSparks();

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ---------- Actions ----------
  function doReset() {
    resize();
    sparks.length = 0;
    if (modeSel.value === "lotto") lottoReset();
    else slotReset();
  }

  function doStart() {
    if (modeSel.value === "lotto") lottoStart();
    else slotStart();
  }

  actionBtn.addEventListener("click", doStart);
  resetBtn.addEventListener("click", doReset);

  modeSel.addEventListener("change", () => {
    doReset();
  });

  // keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space") { e.preventDefault(); doStart(); }
    if (e.key === "r" || e.key === "R") doReset();
    if (e.key === "1") { modeSel.value = "lotto"; doReset(); }
    if (e.key === "2") { modeSel.value = "slot"; doReset(); }
  });

  // init
  doReset();
})();
</script>
</body>
</html>

